consts {
    NumCaches : 2;
    NumValues : 2;
    NumAddresses : 1;
    NumDirs : 1;
}

types {
    CacheIDType : symmetric(NumCaches);
    AddressType : symmetric(NumAddresses);
    ValueType : symmetric(NumValues);
    DirIDType : symmetric(NumDirs);
    
    // range is a (fully) closed range
    AckType : range(-NumCaches, NumCaches);
}

messages {
    foreach c in CacheIDType
    foreach d in CacheIDType
    foreach a in AddressType
        GetXMsg[c][d][a] of unit,
        GetSMsg[c][d][a] of unit,
        WBMsg[c][d][a] of ValueType,

        FwdGetXMsg[c][d][a] of CacheIDType,
        FwdGetSMsg[c][d][a] of CacheIDType,
        InvAckMsg[c][d][a] of ValueType,

        UnblockSMsg[c][d][a] of unit,
        UnblockEMsg[c][d][a] of unit,

        WBAckMsg[c][d][a] of unit,
        DataMsgD[c][d][a] of (ValueType * AckType),
        DataMsgC[c][d][a] of ValueType,

        GetXMsg'[c][d][a] of unit,
        GetSMsg'[c][d][a] of unit,
        WBMsg'[c][d][a] of ValueType,

        UnblockSMsg'[c][d][a] of unit,
        UnblockEMsg'[c][d][a] of unit,

        FwdGetSMsg'[c][d][a] of CacheIDType,
        FwdGetXMsg'[c][d][a] of CacheIDType,
        InvAckMsg'[c][d][a] of ValueType,

        WBAckMsg'[c][d][a] of unit,
        DataMsgD'[c][d][a] of (ValueType * AckType),
        DataMsgC'[c][d][a] of ValueType,


        LDMsg[c][d][a] of unit,
        STMsg[c][d][a] of ValueType,
        EVMsg[c][d][a] of unit,
        LDAckMsg[c][d][a] of ValueType,
        STAckMsg[c][d][a] of ValueType,
        EVAckMsg[c][d][a] of unit;
}

foreach d in DirIDType
foreach a in AddressType
automaton CoherenceMonitor[d][a] with compassion
{
    states {
        Initial : initial;
        Error : error;
    }

    vars {
        LastValue : ValueType;
    }

    inports {
        foreach c in CacheIDType
        STAckMsg[c][d][a],
        LDAckMsg[c][d][a];
    }
    
    transitions {
        Initial on STAckMsg[c][d][a] (v) ->
        { LastValue := v } Initial
        Initial on LDAckMsg[c][d][a] (v)
        if (v != LastValue) ->
        {} Error;
        if (v = LastValue) ->
        {} Initial;
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
automaton Environment[c][a][d] with compassion
{
    states {
        Initial : initial;
        PendingLD;
        PendingST;
        PendingEV;
        Error : error
    }

    vars {
        PendingStore : ValueType;
    }

    inports {
        LDAckMsg[c][d][a];
        STAckMsg[c][d][a];
        EVAckMsg[c][d][a];                
    }

    outports {
        LDMsg[c][d][a];
        STMsg[c][d][a];
        EVMsg[c][d][a];
    }

    transitions {
        // Load flow
        Initial spontaneous send LDMsg[c][d][a] -> {} PendingLD;
        PendingLD on LDAckMsg[c][d][a] (v) -> Initial;

        // Store flow
        foreach v in ValueType
        Initial spontaneous send STMsg[c][d][a] (v) ->
        { PendingStore := v; }
        PendingST

        PendingST on STAckMsg[c][d][a]
        if (v = PendingStore) ->
        {} Initial;
        if (v != PendingStore) ->
        {} Error;
        
        // Evict flow
        Initial spontaneous send EVMsg[c][d][a] ->
        {} PendingEV;
        PendingEV on EVAckMsg[c][d][a] -> 
        {} Initial;
    }
}


// Channel from Cache to Directory for a given Address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton ReqChannel[c][d][a] with compassion
{
    unordered, lossless, nonduplicating;
    capacity = 1;

    messages {
        GetXMsg[c][d][a];
        GetSMsg[c][d][a];
        WBMsg[c][d][a];
    }
}

// Channel INTO each cache for a given address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton RspChannel[c][d][a] with compassion
{
    unordered, lossless, nonduplicating;
    capacity = NumCaches;

    messages {
        InvAckMsg[c][d][a],
        WBAckMsg[c][d][a],
        DataMsgD[c][d][a],
        DataMsgC[c][d][a];
    }
}

// Unblocks INTO each directory for a given address
foreach d in DirIDType
foreach a in AddressType
{
    unordered, lossless, nonduplicating;
    capacity = 1;

    messages {
        foreach c in CacheIDType
            UnblockEMsg[c][d][a],
            UnblockSMsg[c][d][a];
    }
}

// Forward messages INTO each cache for a given address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton FwdChannel[c][d][a]
{
    unordered, lossless, nonduplicating;
    capacity = 1;
    messages {
        FwdGetSMsg[c][d][a];
        FwdGetXMsg[c][d][a];
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
automaton Cache[c][d][a] with compassion
{
    states {
        C_I;
        C_S;
        C_M;
        C_IM;
        C_SM;
        C_IS;
        C_II;
    }

    vars {
        DataBlk : ValueType;
        PendingAcks : AckType;
        PendingWrite : ValueType;
    }

    inports {
        LDMsg[c][d][a];
        STMsg[c][d][a];
        EVMsg[c][d][a];

        FwdGetXMsg'[c][d][a];
        FwdGetSMsg'[c][d][a];
        InvAckMsg'[c][d][a];

        DataMsgD'[c][d][a];
        DataMsgC'[c][d][a]
        WBAckMsg'[c][d][a];
    }
    
    outports {
        LDAckMsg[c][d][a];
        STAckMsg[c][d][a];
        EVAckMsg[c][d][a];

        UnblockSMsg[c][d][a];
        UnblockEMsg[c][d][a];

        GetXMsg[c][d][a];
        GetSMsg[c][d][a];
        WBMsg[c][d][a];

        DataMsgC[c][d][a];
    }

    transitions {

    }
}

foreach d in DirIDType
foreach a in AddressType
automaton Directory[d][a] with compassion
{
    states {

    }

    vars {

    }

    inports {
        foreach c in CacheIDType
            GetXMsg'[c][d][a],
            GetSMsg'[c][d][a],
            WBMsg'[c][d][a],

            UnblockSMsg'[c][d][a],
            UnblockEMsg'[c][d][a],
            
            
    }
}