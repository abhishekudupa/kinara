consts {
    NumCaches : 2;
    NumValues : 2;
    NumAddresses : 1;
    NumDirs : 1;
}

types {
    CacheIDType : symmetric(NumCaches);
    AddressType : symmetric(NumAddresses);
    ValueType : symmetric(NumValues);
    DirIDType : symmetric(NumDirs);
    
    // range is a (fully) closed range
    AckType : range(-NumCaches, NumCaches);
}

messages {
    foreach c in CacheIDType {
        foreach d in CacheIDType {
            foreach a in AddressType {

                GetXMsg[c][d][a] of unit;
                GetSMsg[c][d][a] of unit;
                WBMsg[c][d][a] of ValueType;

                FwdGetXMsg[c][d][a] of CacheIDType;
                FwdGetSMsg[c][d][a] of CacheIDType;
                InvAckMsg[c][d][a] of ValueType;

                UnblockSMsg[c][d][a] of unit;
                UnblockEMsg[c][d][a] of unit;

                WBAckMsg[c][d][a] of unit;
                DataMsgD2C[c][d][a] of (ValueType * AckType);
                DataMsgC2D[c][d][a] of (ValueType * AckType);

                foreach c2 in CacheIDType (!= c c2) {
                    DataMsgC2C[c][c2][d][a];
                }

                GetXMsg'[c][d][a] of unit;
                GetSMsg'[c][d][a] of unit;
                WBMsg'[c][d][a] of ValueType;

                UnblockSMsg'[c][d][a] of unit;
                UnblockEMsg'[c][d][a] of unit;

                FwdGetSMsg'[c][d][a] of CacheIDType;
                FwdGetXMsg'[c][d][a] of CacheIDType;
                InvAckMsg'[c][d][a] of ValueType;

                WBAckMsg'[c][d][a] of unit;
                DataMsgD2C'[c][d][a] of (ValueType * AckType);
                DataMsgC2D'[c][d][a] of (ValueType * AckType);

                foreach c2 in CacheIDType (!= c c2) {
                    DataMsgC2C'[c][c2][d][a] of ValueType;
                }

                LDMsg[c][d][a] of unit;
                STMsg[c][d][a] of ValueType;
                EVMsg[c][d][a] of unit;
                LDAckMsg[c][d][a] of ValueType;
                STAckMsg[c][d][a] of ValueType;
                EVAckMsg[c][d][a] of unit;
            }
        }
    }
}

foreach d in DirIDType
foreach a in AddressType
automaton CoherenceMonitor[d][a] with compassion
{
    states {
        Initial : initial;
        Error : error;
    }

    vars {
        LastValue : ValueType;
    }

    inports {
        foreach c in CacheIDType {
            STAckMsg[c][d][a];
            LDAckMsg[c][d][a];
        }
    }
    
    transitions {
        Initial on STAckMsg[c][d][a] (v) ->
        { LastValue := v } Initial
        Initial on LDAckMsg[c][d][a] (v)
        if (v != LastValue) ->
        {} Error;
        if (v = LastValue) ->
        {} Initial;
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
automaton Environment[c][a][d] with compassion
{
    states {
        Initial : initial;
        PendingLD;
        PendingST;
        PendingEV;
        Error : error
    }

    vars {
        PendingStore : ValueType;
    }

    inports {
        LDAckMsg[c][d][a];
        STAckMsg[c][d][a];
        EVAckMsg[c][d][a];                
    }

    outports {
        LDMsg[c][d][a];
        STMsg[c][d][a];
        EVMsg[c][d][a];
    }

    transitions {
        // Load flow
        Initial spontaneous send LDMsg[c][d][a] -> {} PendingLD;
        PendingLD on LDAckMsg[c][d][a] (v) -> Initial;

        // Store flow
        foreach v in ValueType
        Initial spontaneous send STMsg[c][d][a] (v) ->
        { PendingStore := v; }
        PendingST

        PendingST on STAckMsg[c][d][a]
        if (v = PendingStore) ->
        {} Initial;
        if (v != PendingStore) ->
        {} Error;
        
        // Evict flow
        Initial spontaneous send EVMsg[c][d][a] ->
        {} PendingEV;
        PendingEV on EVAckMsg[c][d][a] -> 
        {} Initial;
    }
}


// Channel from Cache to Directory for a given Address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton ReqChannel[c][d][a] with compassion
{
    unordered, lossless, nonduplicating;
    capacity = 1;

    messages {
        GetXMsg[c][d][a];
        GetSMsg[c][d][a];
        WBMsg[c][d][a];
    }
}

// Channel INTO each cache for a given address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton RspChannel[c][d][a] with compassion
{
    unordered, lossless, nonduplicating;
    capacity = NumCaches;

    messages {
        InvAckMsg[c][d][a],
        WBAckMsg[c][d][a],
        DataMsgD[c][d][a],
        DataMsgC[c][d][a];
    }
}

// Unblocks INTO each directory for a given address
foreach d in DirIDType
foreach a in AddressType
channelautomaton UnblockChannel[d][a]
{
    unordered, lossless, nonduplicating;
    capacity = 1;

    messages {
        foreach c in CacheIDType {
            UnblockEMsg[c][d][a];
            UnblockSMsg[c][d][a];
        }
    }
}

// Forward messages INTO each cache for a given address
foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
channelautomaton FwdChannel[c][d][a]
{
    unordered, lossless, nonduplicating;
    capacity = 1;
    messages {
        FwdGetSMsg[c][d][a];
        FwdGetXMsg[c][d][a];
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
automaton Cache[c][d][a] with compassion
{
    states {
        C_I;
        C_S;
        C_M;
        C_IM;
        C_SM;
        C_IS;
        C_II;
    }

    vars {
        DataBlk : ValueType;
        PendingAcks : AckType;
        PendingWrite : ValueType;
    }

    inports {
        LDMsg[c][d][a];
        STMsg[c][d][a];
        EVMsg[c][d][a];

        FwdGetXMsg'[c][d][a];
        FwdGetSMsg'[c][d][a];
        InvAckMsg'[c][d][a];

        DataMsgD2C'[c][d][a];
        
        WBAckMsg'[c][d][a];

        foreach c1 in CacheIDType (!= c c1) {
            DataMsgC2C'[c1][c][d][a];
        }
    }
    
    outports {
        LDAckMsg[c][d][a];
        STAckMsg[c][d][a];
        EVAckMsg[c][d][a];

        UnblockSMsg[c][d][a];
        UnblockEMsg[c][d][a];

        GetXMsg[c][d][a];
        GetSMsg[c][d][a];
        WBMsg[c][d][a];

        foreach c1 in CacheIDType (!= c c1) {
            DataMsgC2C[c][c1][d][a];
        }
    }

    transitions {
        
    }
}

foreach d in DirIDType
foreach a in AddressType
automaton Directory[d][a] with compassion
{
    states {
        D_I,
        D_S,
        D_M,
        D_BUSY,
        D_DATA
    }

    vars {
        DataBlk : ValueType;
        ActiveId : CacheIDType;
        Sharers : array[CacheIDType] of boolean;
    }

    inports {
        foreach c in CacheIDType {
            GetXMsg'[c][d][a];
            GetSMsg'[c][d][a];
            WBMsg'[c][d][a];

            UnblockSMsg'[c][d][a];
            UnblockEMsg'[c][d][a];

            DataMsgC2D'[c][d][a];
        }
    }

    outports {
        foreach c in CacheIDType {
            FwdGetXMsg[c][d][a];
            FwdGetSMsg[c][d][a];
            DataMsgD2C[c][d][a];
        }
    }
}

initialstate {
    foreach d in DirIDType
    foreach a in AddressType {
        CoherenceMonitor.state = Initial;
        foreach v in ValueType {
            CoherenceMonitor.LastValue = v;
            Directory[d][a].DataBlk = v;
        }
        Directory[d][a].ActiveId = undef;
        Directory[d][a].state = D_I;
        
        foreach c in CacheIDType {
            Directory[d][a].Sharers[c] = false;
            Cache[c][d][a].DataBlk = undef;
            Cache[c][d][a].PendingAcks = 0;
            Cache[c][d][a].PendingWrite = undef;
            Environment[c][d][a].state = Initial;
            Environment[c][d][a].PendingStore = undef;
            Cache[c][d][a].state = C_I;
        }
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
invariant CoherenceInvariant
{
    (-> (= Cache[c][d][a].state S) 
        (= Cache[c][d][a].DataBlk 
           CoherenceMonitor[d][a].LastValue))
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
messageproperty LoadLivenessMonitor
{
    states {

    }

    inports {
        LDMsg[c][d][a];
        LDAckMsg[c][d][a];
    }

    property {
        (G (-> LDMsg[c][d][a] (F LDAckMsg[c][d][a])))
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
stateproperty StoreLivenessMonitor
{
    property {
        (G (-> (= Environment[c][d][a].state PendingSt) 
               (F (Environment[c][d][a].state Initial))))
    }
}

foreach c in CacheIDType
foreach d in DirIDType
foreach a in AddressType
messagemonitor WBLivenessMonitor
{
    states {
        MWB_Initial : initial;
        MWB_Accept : accepting;
    }

    inports {
        EVMsg[c][d][a]
    }

    transitions {
        MWB_Initial on all -> {} MWB_Initial;
        MWB_Initial on EVMsg[c][d][a] -> {} MWB_Accept;
        MWB_Accept on all but { EVAckMsg[c][d][a] } -> MWB_Accept;
    }
}

